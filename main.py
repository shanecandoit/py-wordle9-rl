import json
import csv
import io
import random
import time
from datetime import datetime
from typing import List, Dict, Any

from ollama import Client
from rich.console import Console
from rich.table import Table

# Configuration constants
OLLAMA_HOST = 'http://localhost:11434'
MODEL_NAME = "gemma3:1b"
MAX_GUESSES = 6
NUM_GAMES = 9
WORDLIST_FILE = "wordlist.txt"
FINAL_GUESS_MARKER = "Final Guess:"

# Initialize Ollama client
ollama_client = Client(host=OLLAMA_HOST)


def load_wordlist() -> List[str]:
    """Load words from the wordlist file."""
    with open(WORDLIST_FILE, "r") as file:
        return file.read().splitlines()


def initialize_games() -> List[Dict[str, Any]]:
    """
    Initialize nine Wordle games with unique target words.
    Returns:
        List of game states, each containing the target word and current state.
    """
    words = load_wordlist()
    target_words = random.sample(words, NUM_GAMES)
    
    return [
        {"target_word": word, "guesses": [], "feedback": []}
        for word in target_words
    ]


def create_wordle_prompt(game_states: List[Dict[str, Any]]) -> str:
    """Create the prompt for the AI agent."""
    # Remove target words from game states for the agent
    sanitized_states = [
        {key: value for key, value in game.items() if key != "target_word"}
        for game in game_states
    ]
    state_csv = generate_csv_content(game_states)
    
    return (
        "You are an expert Wordle player. "
        "Based on the current game states, generate a single 5-letter word guess. "
        "You are playing nine games of Wordle at the same time.\n"
        # f"States: {sanitized_states}\n"
        "The game state as a csv: \n"
        f"{state_csv} \n"
        "The indicators mean: _r_: r is wrong letter (grey/bad), -s-: s is right letter, wrong spot (yellow/ok), =t=: t is right spot (green/great). \n"
        "---\n"
        "First, do some reasoning about each board. "
        "Second, do some reasoning about the letters you see. "
        "Third, do some reasoning about the letters you have not seen. "
        "Fourth, do some reasoning about the grey and yellow letters specifically. "
        "Finally, make a 5-letter word guess. "
        "End your response with 'Final Guess: <your_guess>'."
    )


def get_agent_guess(game_states: List[Dict[str, Any]]) -> str:
    """
    Get a guess from the AI agent based on current game states.
    Args:
        game_states: The current state of all nine games.
    Returns:
        A single 5-letter word guess.
    """
    prompt = create_wordle_prompt(game_states)
    
    response = ollama_client.chat(
        model=MODEL_NAME, 
        messages=[{'role': 'user', 'content': prompt}]
    )
    
    response_content = response.get("message", {}).get("content", "").strip().lower()
    guess = extract_final_guess(response_content)
    
    if is_valid_guess(guess):
        return guess
    else:
        raise ValueError("Invalid guess generated by the agent.")


def is_valid_guess(guess: str) -> bool:
    """Check if a guess is valid (5 letters, alphabetic, lowercase)."""
    return len(guess) == 5 and guess.isalpha() and guess.islower()


def generate_feedback(guess: str, target_word: str) -> List[str]:
    """
    Generate feedback for a guess against a target word.
    Returns:
        List of feedback colors: 'green', 'yellow', or 'grey'
    """
    feedback = []
    for i, letter in enumerate(guess):
        if letter == target_word[i]:
            feedback.append("green")  # Correct letter and position
        elif letter in target_word:
            feedback.append("yellow")  # Correct letter, wrong position
        else:
            feedback.append("grey")  # Incorrect letter
    return feedback


def apply_guess_to_games(guess: str, game_states: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    """
    Apply the agent's guess to all nine games and generate tile feedback.
    Args:
        guess: The agent's 5-letter word guess.
        game_states: The current state of all nine games.
    Returns:
        Updated game states with feedback applied.
    """
    for game in game_states:
        feedback = generate_feedback(guess, game["target_word"])
        game["guesses"].append(guess)
        game["feedback"].append(feedback)
    
    return game_states


def is_game_won(game: Dict[str, Any]) -> bool:
    """Check if a single game is won."""
    return game["guesses"] and game["guesses"][-1] == game["target_word"]


def is_game_over(game_states: List[Dict[str, Any]]) -> bool:
    """
    Check if all games are complete (either won or max guesses reached).
    Args:
        game_states: The current state of all nine games.
    Returns:
        True if all games are complete, False otherwise.
    """
    for game in game_states:
        if is_game_won(game):
            continue
        if len(game["guesses"]) < MAX_GUESSES:
            return False
    return True


def compile_report(game_states: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Compile a comprehensive report of the game results.
    Args:
        game_states: The final state of all nine games.
    Returns:
        A report containing game details and scores.
    """
    report = {
        "games": [],
        "summary": {
            "total_games": len(game_states),
            "games_won": 0,
            "games_lost": 0,
            "grey_count": 0,
            "yellow_count": 0,
            "green_count": 0
        }
    }

    for game in game_states:
        game_result = {
            "target_word": game["target_word"],
            "guesses": game["guesses"],
            "feedback": game["feedback"],
            "status": "won" if is_game_won(game) else "lost"
        }

        report["games"].append(game_result)

        if game_result["status"] == "won":
            report["summary"]["games_won"] += 1
        else:
            report["summary"]["games_lost"] += 1

        # Count feedback colors
        for feedback in game["feedback"]:
            report["summary"]["grey_count"] += feedback.count("grey")
            report["summary"]["yellow_count"] += feedback.count("yellow")
            report["summary"]["green_count"] += feedback.count("green")

    return report


def save_report(report: Dict[str, Any], filename: str = "game_report.json") -> None:
    """Save the game report to a JSON file."""
    with open(filename, "w") as file:
        json.dump(report, file, indent=2)
    print(f"Report saved to {filename}")


def display_board(game_states: List[Dict[str, Any]]) -> None:
    """
    Display the current state of all nine Wordle games using Rich.
    Args:
        game_states: The current state of all nine games.
    """
    console = Console()
    table = Table(title="Wordle Game States")

    # Add columns for each game
    for i in range(1, NUM_GAMES + 1):
        table.add_column(f"Game {i}")

    # Determine the maximum number of guesses across all games
    max_guesses = max(len(game["guesses"]) for game in game_states) if game_states else 0

    # Add rows for each guess
    for guess_index in range(max_guesses):
        row = []
        for game in game_states:
            if guess_index < len(game["guesses"]):
                guess = game["guesses"][guess_index]
                feedback = game["feedback"][guess_index]
                colored_guess = format_colored_guess(guess, feedback)
                row.append(colored_guess)
            else:
                row.append("")
        table.add_row(*row)

    console.print(table)


def format_colored_guess(guess: str, feedback: List[str]) -> str:
    """Format a guess with color coding based on feedback."""
    return "".join(
        f"[green]{letter}[/green]" if color == "green" else
        f"[yellow]{letter}[/yellow]" if color == "yellow" else
        f"[grey]{letter}[/grey]"
        for letter, color in zip(guess, feedback)
    )


def extract_final_guess(llm_response: str) -> str:
    """
    Extract the final guess from the LLM response.
    Args:
        llm_response: The response text from the LLM.
    Returns:
        The extracted 5-letter word guess.
    """
    # Look for the 'Final Guess:' marker
    start_index = llm_response.find(FINAL_GUESS_MARKER)

    if start_index != -1:
        # Extract the text after the marker
        guess = llm_response[start_index + len(FINAL_GUESS_MARKER):].strip().split()[0]
        guess = guess.lower()

        # Validate the guess
        if is_valid_guess(guess):
            return guess
        
    # If no valid guess found, try to find one from the wordlist
    print("No valid 'Final Guess' found, trying to find a valid guess from the wordlist.")
    return find_closest_from_wordlist(llm_response)


def find_closest_from_wordlist(text: str) -> str:
    """
    Find the closest valid 5-letter word from the wordlist.
    Args:
        text: The text to search for valid words.
    Returns:
        A valid 5-letter word from the wordlist.
    """
    words = load_wordlist()
    valid_words = [word for word in words if is_valid_guess(word)]

    # Find words that share letters with the input text
    text_letters = set(text.lower())
    close_words = [
        word for word in valid_words 
        if text_letters.intersection(set(word))
    ]

    if close_words:
        selected_word = random.choice(close_words)
        print(f'Returning closest valid word from wordlist: {selected_word}')
        return selected_word

    # Fallback to random word
    selected_word = random.choice(valid_words)
    print(f'No close match found, returning random valid word: {selected_word}')
    return selected_word


def generate_csv_content(game_states: List[Dict[str, Any]]) -> str:
    """
    Generate the game progress as a CSV string.
    Args:
        game_states: The current state of all nine games.
    Returns:
        The CSV content as a string.
    """
    # Prepare headers
    headers = [f"Game{i+1}" for i in range(len(game_states))] + ["n_grey", "n_yellow", "n_green"]

    # Determine the maximum number of guesses
    max_guesses = max(len(game["guesses"]) for game in game_states) if game_states else 0

    # Prepare rows
    rows = []
    for guess_index in range(max_guesses):
        row = []
        n_grey = n_yellow = n_green = 0

        for game in game_states:
            if guess_index < len(game["guesses"]):
                guess = game["guesses"][guess_index]
                feedback = game["feedback"][guess_index]
                formatted_guess = format_csv_guess(guess, feedback)
                row.append(formatted_guess)
                
                # Count feedback colors
                n_grey += feedback.count("grey")
                n_yellow += feedback.count("yellow")
                n_green += feedback.count("green")
            else:
                row.append("")

        row.extend([n_grey, n_yellow, n_green])
        rows.append(row)

    # Write to CSV string
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(headers)
    writer.writerows(rows)
    return output.getvalue()


def format_csv_guess(guess: str, feedback: List[str]) -> str:
    """Format a guess for CSV output with feedback indicators."""
    return "".join(
        f"={letter}=" if color == "green" else
        f"-{letter}-" if color == "yellow" else
        f"_{letter}_"
        for letter, color in zip(guess, feedback)
    )


def save_csv_report(game_states: List[Dict[str, Any]], output_file: str = "game_progress.csv") -> None:
    """
    Save the game progress as a CSV file with summary information.
    Args:
        game_states: The current state of all nine games.
        output_file: The name of the output CSV file.
    """
    # Generate the main game progress CSV content
    csv_content = generate_csv_content(game_states)
    
    # Generate summary from the report
    report = compile_report(game_states)
    summary = report["summary"]
    
    with open(output_file, "w", newline="") as csvfile:
        # Write the main game progress
        csvfile.write(csv_content)
        
        # Add a blank line separator
        csvfile.write("\n")
        
        # Write summary section
        writer = csv.writer(csvfile)
        writer.writerow(["SUMMARY"])
        writer.writerow(["Metric", "Value"])
        writer.writerow(["Total Games", summary["total_games"]])
        writer.writerow(["Games Won", summary["games_won"]])
        writer.writerow(["Games Lost", summary["games_lost"]])
        writer.writerow(["Grey Count", summary["grey_count"]])
        writer.writerow(["Yellow Count", summary["yellow_count"]])
        writer.writerow(["Green Count", summary["green_count"]])
        
        # Calculate win rate
        win_rate = (summary["games_won"] / summary["total_games"]) * 100 if summary["total_games"] > 0 else 0
        writer.writerow(["Win Rate (%)", f"{win_rate:.1f}"])
    
    print(f"CSV file '{output_file}' generated successfully.")


def main() -> None:
    """Main function to run the Wordle simulation."""
    console = Console()

    # Initialize games
    game_states = initialize_games()
    display_board(game_states)
    console.print('CSV:\n', generate_csv_content(game_states))

    # Play rounds until all games are complete
    while not is_game_over(game_states):
        # Get a guess from the agent
        guess = get_agent_guess(game_states)
        
        # Apply the guess to all games
        game_states = apply_guess_to_games(guess, game_states)
        
        # Display the current game board
        display_board(game_states)
        console.print('CSV:\n', generate_csv_content(game_states))

    # Compile and save the report
    report = compile_report(game_states)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Save JSON report
    json_filename = f"reports/game_{timestamp}.json"
    save_report(report, json_filename)
    
    # Save CSV report
    csv_filename = json_filename.replace(".json", ".csv")
    save_csv_report(game_states, csv_filename)


if __name__ == "__main__":
    main()